/**
 * @file Path.cpp
 * @brief 实现路径数据的序列化、反序列化、校验、比较运算符等
 * @author Generated by create_project_structure.sh
 * @date 2025-06-12
 */

#include "Path.h"

#include "utils/utils.h"

namespace dm {
double Path::get_length() {
  if (length.has_value()) {
    return length.value();
  }
  std::vector<std::pair<float, float>> locs;
  for (const auto &pin : path | std::views::filter([](const auto &pin) {
                           return pin->location != std::make_pair(0., 0.);
                         })) {
    locs.push_back(pin->location);
  }
  double len = manhattan_distance(locs);
  length = len;
  return len;
}

double Path::get_detour() {
  if (detour.has_value()) {
    return detour.value();
  }
  std::vector<std::pair<float, float>> all_locs;
  for (const auto &pin : path | std::views::filter([](const auto &pin) {
                           return pin->location != std::make_pair(0., 0.);
                         })) {
    all_locs.push_back(pin->location);
  }
  if (all_locs.size() < 2) {
    return 0;
  }
  std::vector<std::pair<float, float>> locs = {all_locs.front(),
                                               all_locs.back()};
  double len = manhattan_distance(locs);
  double det = get_length() / len;
  detour = det;
  return det;
}

double Path::get_delay() {
  if (total_delay.has_value()) {
    return total_delay.value();
  }
  double delay = 0;
  for (const auto &pin : path) {
    delay += pin->incr_delay;
  }
  total_delay = delay;
  return delay;
}

double Path::get_cell_delay_pct() {
  if (cell_delay_pct.has_value()) {
    return cell_delay_pct.value();
  }
  double cell_delay = 0;
  for (const auto &pin : path | std::views::filter([](const auto &pin) {
                           return !pin->is_input;
                         })) {
    cell_delay += pin->incr_delay;
  }
  double total_delay = get_delay();
  double pct = cell_delay / total_delay;
  cell_delay_pct = pct;
  return pct;
}
}  // namespace dm
